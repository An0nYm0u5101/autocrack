#include "parser.h"

extern struct _globals globals;

enum _type parser_type(const char *arg, const char *file,int line_no)
{
	char *ptr,*str;
	int i;
	size_t len;
	
	if(arg==NULL)
		w_report_error("calling with NULL argument.",file,line_no,__func__,0,1,error);
	
	// convert type to uppercase
	len = strlen(arg);
	str = (char *) malloc(len*sizeof(char));
	strncpy(str,arg,len);
	for(ptr=str;*ptr!='\n'&&*ptr!='\0';ptr++)
		*ptr = (char) toupper(*ptr);
	*ptr = '\0';
	
	// search type in type_str ( i=1, NONE not recognized )
	for( i=1; i<N_TYPE; i++)
		if( len == strlen(type_str[i]) && !strncmp(type_str[i],str,len))
			break;
	if(i!=N_TYPE)
		return i;
	snprintf(	globals.err_buff,MAX_BUFF,
						"type \"%s\" is unknown.",arg);
	w_report_error(globals.err_buff,file,line_no,__func__,0,0,warning);
	return UNKNOWN;
}

const char *parser_hash(enum _type type, const char* arg, const char *file, int line_no)
{
	char *str;
	int i;
	
	if(arg == NULL)
		w_report_error("called with NULL argument.",file,line_no,__func__,0,1,error);
	
	if(type != NONE && type != UNKNOWN)
		str = regexp(arg,type_rgx[type]);
	else
		//try all regex against given hash
		for(i=1;i<(N_TYPE -1) && ( str = regexp(arg,type_rgx[i]) ) == NULL ;i++);
	
	if ( str == NULL && globals.log_level>=verbose )
	{
		w_report_error("bad hash",file,line_no,__func__,0,0,verbose2);
		snprintf(globals.err_buff,MAX_BUFF,"\thash: %s",arg);
		w_report_error(globals.err_buff,file,line_no,__func__,0,0,verbose2);
		snprintf(globals.err_buff,MAX_BUFF,"\ttype: %s",type_str[type]);
		w_report_error(globals.err_buff,file,line_no,__func__,0,0,verbose3);
	}
	
	return str;
}

void parser_hash_list(const char *file, int line_no)
{
	_hash *tmp,*old;
	
	for(tmp=globals.hash_list;tmp!=NULL;)
	{
		if( tmp->type == UNKNOWN || tmp->type == NONE )
		{
			if(tmp->hash != NULL)
			{
				snprintf(	globals.err_buff,MAX_BUFF,"unknown type for hash \"%s\" .",tmp->hash);
				w_report_error(globals.err_buff,file,line_no,__func__,0,0,info);
				
				snprintf(	globals.err_buff,MAX_BUFF,"hash: \"%s\" deleted.",tmp->hash);
			}
			else
			{
				snprintf(	globals.err_buff,MAX_BUFF,"missing hash for entry #%u .", tmp->id);
				w_report_error(globals.err_buff,file,line_no,__func__,0,0,info);
				
				snprintf(	globals.err_buff,MAX_BUFF,"entry #%u deleted.",tmp->id);
			}
			old=tmp;
			tmp = tmp->next;
			w_del_hash(old,file,line_no);
			w_report_error(globals.err_buff,file,line_no,__func__,0,0,warning);
		}
		else if( parser_hash(tmp->type,tmp->hash,file,line_no) == NULL )
		{
			snprintf(	globals.err_buff,MAX_BUFF,"hash \"%s\" is not in \"%s\" format.",tmp->hash,type_str[tmp->type]);
			w_report_error(globals.err_buff,file,line_no,__func__,0,0,info);
			
			snprintf(	globals.err_buff,MAX_BUFF,"hash \"%s\" deleted.",tmp->hash);
			old=tmp;
			tmp = tmp->next;
			w_del_hash(old,file,line_no);
			w_report_error(globals.err_buff,file,line_no,__func__,0,0,warning);
		}
		else
			tmp = tmp->next;
	}
	
	return;
}

void parser_infile(const char *infile)
{
	FILE *fin;
	char line[MAX_LINE],*type;
	const char *hash;
	enum _type my_type;
	int inline_no;
	
	// check file
	if( access(infile,R_OK) || (fin = fopen(infile,"r")) == NULL )
		report_error(infile,1,1,error);
	
	inline_no = 0;
	my_type = UNKNOWN;
	
	fgets( line, MAX_LINE, fin);
	while( !feof(fin) )
	{
		inline_no++;
		
		fgets_fix(line);
		type = regexp(line,"[^$]+");
		if(type == NULL)
		{
			snprintf(	globals.err_buff,MAX_BUFF,
								"format error in file \"%s\" at line #%d .",infile,inline_no);
			report_error(globals.err_buff,0,0,error);
			continue;
		}
		hash = regexp(line + strlen(type) +1,"[^$]+");
		
		if( (my_type = P_type(type) ) == UNKNOWN )
		{
			snprintf(	globals.err_buff,MAX_BUFF,
								"unknown type in file \"%s\" at line #%d .",infile,inline_no);
			report_error(globals.err_buff,0,0,warning);
		}
		else if( ( hash = P_hash(my_type,hash) ) == NULL )
		{
			snprintf(	globals.err_buff,MAX_BUFF,
								"wrong hash format in file \"%s\" at line #%d .",infile,inline_no);
			report_error(globals.err_buff,0,0,warning);
		}
		else
			add_hash(my_type,hash);
		fgets( line, MAX_LINE, fin);
	}
	fclose(fin);
	P_hash_list();
	return;
}

void parser_essid(const char *arg, const char *file, int line_no)
{
	char *rt_file,line[MAX_LINE];
	FILE *ssid;
	
	if(arg == NULL)
	{
		snprintf(globals.err_buff,MAX_BUFF,"called with NULL argument.");
		w_report_error(globals.err_buff,file,line_no,__func__,0,1,error);
	}
	else	if( globals.rain == true &&  globals.rt_root == NULL )
	{
		snprintf(line,MAX_LINE,"%s/%s",CONFDIR,DEF_RT_ROOT);
		P_rt_root(line);
		if( globals.rt_root == NULL )
		{
			snprintf(	globals.err_buff,MAX_BUFF,
								"cannot set RT_ROOT at default value \"%s\".",DEF_RT_ROOT);
			report_error(globals.err_buff,0,0,verbose);
		}
		else
		{
			snprintf(	globals.err_buff,MAX_BUFF,
								"RT_ROOT is now at default value \"%s\".",DEF_RT_ROOT);
			report_error(globals.err_buff,0,0,verbose3);
		}
	}
	
	if( globals.rain == true)
	{
		if( ( rt_file = find_file(globals.rt_root,"SSID.txt") ) == NULL )
		{
			snprintf(globals.err_buff,MAX_BUFF,"could not find \"SSID.txt\" .");
			w_report_error(globals.err_buff,file,line_no,__func__,0,0,warning);
		}
		else if( ( ssid = fopen(rt_file,"r") ) == NULL )
		{
			snprintf(globals.err_buff,MAX_BUFF,"unable to open \"SSID.txt\" .");
			w_report_error(globals.err_buff,file,line_no,__func__,0,0,error);
		}
		else
		{
			while( fgets(line, MAX_LINE, ssid) != NULL )
				if( fnmatch(fgets_fix(line),arg,FNM_PATHNAME) == 0)
					break;
			
			if(line == NULL)
			{
				snprintf(	globals.err_buff,MAX_BUFF,
									"no rainbow table for \"%s\".", arg);
				w_report_error(globals.err_buff,file,line_no,__func__,0,0,info);
			}
			else
				argcpy(&globals.essid,line,MAX_LINE);
			
			fclose(ssid);
		}
	}
	else 
	{ 
		if( globals.essid == NULL)
		{
			snprintf(globals.err_buff,MAX_BUFF,"essid set to \"%s\".",arg);
			w_report_error(globals.err_buff,file,line_no,__func__,0,0,verbose2);
			argcpy(&globals.essid,arg,NAME_MAX);
		}
		else
		{
			snprintf(	globals.err_buff,MAX_BUFF,
								"kept old essid \"%s\".",basename((char *)globals.essid));
			w_report_error(globals.err_buff,file,line_no,__func__,0,0,info);
		}
	}
	return;
	
}

void parser_rt_root(const char *arg, const char *file, int line_no)
{
	struct stat rt_root_stat;
	char *tmp;
	
	
	if(arg == NULL)
	{
		snprintf(globals.err_buff,MAX_BUFF,"called with NULL argument.");
		w_report_error(globals.err_buff,file,line_no,__func__,0,1,error);
	}	
	else if(lstat(arg,&rt_root_stat) != 0) // if couldn't get argument stats
	{
		snprintf(	globals.err_buff,MAX_BUFF,
							"\"%s\" ",arg);
		w_report_error(globals.err_buff,file,line_no,__func__,1,0,error);
	}
	else if(S_ISLNK(rt_root_stat.st_mode) && S_ISDIR(rt_root_stat.st_mode)) // if isn't a directory or a link
	{
		snprintf(	globals.err_buff,MAX_BUFF,
							"\"%s\" is not a link or directory.",arg);
		report_error(globals.err_buff,0,0,error);
	}
	else if(access(arg,R_OK) != 0) // if cannot access to argument
	{
		snprintf(globals.err_buff,MAX_BUFF,"\"%s\" ",arg);
		w_report_error(globals.err_buff,file,line_no,__func__,0,0,error);
	}
	else
	{
		argcpy(&globals.rt_root,arg,NAME_MAX);
		if( globals.rain == false )
		{
			report_error("switching on rainbow tables features.",0,0,info);
			globals.rain = true;
		}
		if(globals.essid != NULL)
		{
			tmp = (char *) globals.essid;
			P_essid((const char *)tmp);
			free(tmp);
		}
		return;
	}
	
	if(globals.rt_root == NULL && globals.rain == true) // if there is no rt_root
	{
		report_error("switching off rainbow tables features.",0,0,info);
		globals.rain = false;
	}
	return;
}

void parser_wordlist(const char *arg, const char *file, int line_no)
{
	struct stat wrd_stat;
	const char *target_mime = "text/plain";
	
	
	if(arg == NULL)
		report_error("called with NULL argument.",0,1,error);
	else if( stat(arg,&wrd_stat) ) // if can't get file stats
	{
		snprintf(globals.err_buff,MAX_BUFF,"\"%s\"",arg);
		w_report_error(globals.err_buff,file,line_no,__func__,1,0,error);
	}
	else if( S_ISREG(wrd_stat.st_mode) == 0 ) // if isn't a regular file
	{
		snprintf(globals.err_buff,MAX_BUFF,"\"%s\" is not a regular file.",arg);
		w_report_error(globals.err_buff,file,line_no,__func__,0,0,warning);
	}
	else if( access(arg,R_OK) != 0)
	{
		snprintf(globals.err_buff,MAX_BUFF,"\"%s\"",arg);
		w_report_error(globals.err_buff,file,line_no,__func__,1,0,error);
	}
	else
	{
		if(strncmp(get_mime(arg),target_mime,strlen(target_mime)) != 0)
		{
			snprintf(globals.err_buff,MAX_BUFF,"\"%s\" is not a \"%s\" file.",arg,target_mime);
			w_report_error(globals.err_buff,file,line_no,__func__,0,0,info);
		}
		
		if(globals.dict == false)
		{
			report_error("switching on dictionary features...",0,0,info);
			globals.dict = true;
		}
		argcpy(&globals.wordlist,arg,NAME_MAX);
	}
	
	if(globals.wordlist != NULL )
	{
		if( strncmp(globals.wordlist,arg,NAME_MAX) != 0)
		{
			snprintf(globals.err_buff,MAX_BUFF,"kept old \"%s\" wordlist.",globals.wordlist);
			w_report_error(globals.err_buff,file,line_no,__func__,0,0,info);
		}
		else
		{
			snprintf(globals.err_buff,MAX_BUFF,"wordlist is now \"%s\" .",arg);
			w_report_error(globals.err_buff,file,line_no,__func__,0,0,verbose2);
		}
	}
	else
	{
		w_report_error("switching off dictionary features...",file,line_no,__func__,0,0,info);
		globals.dict = false;
	}
	return;
}

void parser_capture(const char *arg, const char*file, int line_no)
{
	struct stat cap_stat;
	const char *target_mime = "application/octet-stream";
	
	if(arg == NULL)
		report_error("called with NULL argument.",0,1,error);
	else if( stat(arg,&cap_stat) ) // if can't get file stats
	{
		snprintf(globals.err_buff,MAX_BUFF,"\"%s\"",arg);
		w_report_error(globals.err_buff,file,line_no,__func__,1,0,error);
	}
	else if( S_ISREG(cap_stat.st_mode) == 0 ) // if isn't a regular file
	{
		snprintf(globals.err_buff,MAX_BUFF,"\"%s\" is not a regular file.",arg);
		w_report_error(globals.err_buff,file,line_no,__func__,0,0,warning);
	}
	else if( access(arg,R_OK) != 0)
	{
		snprintf(globals.err_buff,MAX_BUFF,"\"%s\"",arg);
		w_report_error(globals.err_buff,file,line_no,__func__,1,0,error);
	}
	else if( 	globals.bins.cow != NULL &&
						execl(globals.bins.cow, globals.bins.cow, "-c", "-r", arg, NULL) != 0 )
	{
		snprintf(globals.err_buff,MAX_BUFF,"\"%s\" hasn't a valid 4-way handshake.",arg);
		w_report_error(globals.err_buff,file,line_no,__func__,0,0,warning);
	}
	else
	{
		if(strncmp(get_mime(arg),target_mime,strlen(target_mime)) != 0)
		{
			snprintf(globals.err_buff,MAX_BUFF,"\"%s\" is not an \"%s\" file.",arg,target_mime);
			w_report_error(globals.err_buff,file,line_no,__func__,0,0,info);
		}
		
		argcpy(&globals.pcap,arg,NAME_MAX);
	}
	
	if(globals.pcap != NULL )
	{
		if( strncmp(globals.pcap,arg,NAME_MAX) != 0)
		{
			snprintf(globals.err_buff,MAX_BUFF,"kept old \"%s\" capture file.",globals.pcap);
			w_report_error(globals.err_buff,file,line_no,__func__,0,0,info);
		}
		else
		{
			snprintf(globals.err_buff,MAX_BUFF,"capture file is now \"%s\" .",arg);
			w_report_error(globals.err_buff,file,line_no,__func__,0,0,verbose2);
		}
	}
	
	return;
}

void parser_path(const char *argv0 )
{
	char 	my_path[PATH_MAX],
				bin_path[PATH_MAX],
				*bins[N_BINS],
				**ptr;
	int		i;
	size_t len;
	
	// defines are provided by ./configure
	bins[0] = JTR;
	bins[1] = COWPATTY;
	bins[2] = PYRIT;
	bins[3] = RCRACK;
	
	if(realpath(argv0,my_path) == NULL)
		report_error(argv0,1,1,error);
	strncpy(my_path,dirname(my_path),PATH_MAX);
	for(i=0;i<N_BINS;i++)
	{
		strncpy(globals.err_buff,bins[i],PATH_MAX); // use globals.err_buff as buffer 'couse realpath() modify the input string
		if( realpath(globals.err_buff,bin_path) == NULL) // remove extra symbols ( [./..] ) and test file existence
		{
			// if bins[i] isn't a full path
			snprintf(globals.err_buff,PATH_MAX,"%s/%s",my_path,bins[i]);
			if(realpath(globals.err_buff,bin_path) == NULL)
			{
				report_error(globals.err_buff,1,1,error);
				continue;
			}
		}
		
		if( access(bin_path,X_OK) )
			report_error(bin_path,1,1,error);
		else
		{
			len = strlen(bin_path) + 1;
			ptr = (char **) &globals.bins;
			ptr += i;
			*ptr = malloc(len*sizeof(char));
			strncpy(*ptr,bin_path,len);
		}
	}
	return;
}

void parser_odb( const char *arg )
{
	odb *tmp=NULL,*old=NULL;
	FILE *db_file;
	struct stat db_stat;
	size_t odb_len,sep_len,skip_len,line_len;
	char line[MAX_LINE];
	int count,i;
	bool empty,rm_head;
	const char *target_mime = "application/octet-stream";
	
	if(arg == NULL)
		report_error("called with NULL argument.",0,1,error);
	else if( globals.odb != NULL )
	{
		snprintf(globals.err_buff,MAX_BUFF,"online servers database yet loaded.");
		report_error(globals.err_buff,0,0,info);
	}
	else if( stat(arg,&db_stat) )
	{
		snprintf(globals.err_buff,MAX_BUFF,"\"%s\"",arg);
		report_error(globals.err_buff,1,0,error);
	}
	else if( S_ISREG(db_stat.st_mode) == 0 ) 
	{
		snprintf(globals.err_buff,MAX_BUFF,"\"%s\" is not a regular file.",arg);
		report_error(globals.err_buff,0,0,warning);
	}
	else if( access(arg,R_OK) != 0)
	{
		snprintf(globals.err_buff,MAX_BUFF,"\"%s\"",arg);
		report_error(globals.err_buff,1,0,error);
	}
	else if ( ( db_file = fopen(arg,"r") ) == NULL )
	{
		snprintf(globals.err_buff,MAX_BUFF,"\"%s\"",arg);
		report_error(globals.err_buff,1,0,error);
	}
	else
	{
		if(strncmp(get_mime(arg),target_mime,strlen(target_mime)) != 0)
		{
			snprintf(globals.err_buff,MAX_BUFF,"\"%s\" is not an \"%s\" file.",arg,target_mime);
			report_error(globals.err_buff,0,0,info);
		}
		
		odb_len = sizeof(odb);
		sep_len = sizeof(ODB_SEP);
		skip_len = sizeof(ODB_SKIP);
		tmp = globals.odb = malloc(odb_len);
		rm_head = false;
		
		for(i=-3,count=0;count < MAX_ODB && !feof(db_file); count++,tmp = tmp->next = malloc(odb_len),tmp->next=NULL)
			for(i=-3;i < MAX_ODB_T && !feof(db_file); i++)
			{
				fgets(line,MAX_LINE,db_file);
				fgets_fix(line);
				line_len = strlen(line);
				
				if( (strncmp(line,ODB_SEP,sep_len)) == 0 )
					break;
				else if( (strncmp(line,ODB_SKIP,skip_len)) == 0 )
				{
					continue;
					i--;
				}
				else if( i < 0 )
				{
					switch(i)
					{
						case -3 :
									tmp->host = (const char *) regexp(line,"[^/]+");
									argcpy(&tmp->file,(line + strlen(tmp->host) +1 ),line_len);
									break;
						case -2 :
									tmp->type = atoi(line);
									break;
						case -1 :
									argcpy(&(tmp->patrn),line,line_len);
									break;
						default :
									snprintf(globals.err_buff,MAX_BUFF,"error in file \"%s\" at record #%d.",arg,count+1);
									report_error(globals.err_buff,0,0,error);
									snprintf(globals.err_buff,MAX_BUFF,"line counter of record #%d is %d.",count+1,i);
									report_error(globals.err_buff,0,1,debug);
									break;
					}
				}
				else
				{
					if ( (tmp->names[i] = regexp(line,"[^=]+")) == NULL)
					{
						if( strlen(line) > 0 )
							snprintf(globals.err_buff,MAX_BUFF,"entry #%d in record #%d start with '=' .", count+1 , i+1);
						else
							snprintf(globals.err_buff,MAX_BUFF,"entry #%d in record #%d is empty.",count+1,i+1);
						report_error(globals.err_buff,0,0,warning);
					}
					else
						argcpy(&tmp->values[i],(line + strlen(tmp->names[i]) +1 ),line_len);
				}
			}
		
		//check for what reason we are exit from loop
		if( count >= MAX_ODB)
		{
			report_error("too much 'onilne database' records.",0,0,warning);
			snprintf(globals.err_buff,MAX_BUFF,"database can holds at most %d records.",MAX_ODB);
			report_error(globals.err_buff,0,0,verbose);
		}
		else if( i > MAX_ODB_T)
		{
			snprintf(globals.err_buff,MAX_BUFF,"record #%d has too many entries.",count);
			report_error(globals.err_buff,0,0,warning);
		}
		fclose(db_file);
		free((void *) tmp);
	}
	
	// global flags Handler
	if ( globals.odb == NULL )
	{
		if ( globals.online == true )
			report_error("switching off online features.",0,0,info);
		globals.online = false;
		return;
	}
	else
	{
		if (globals.online == false)
			report_error("switching on onine features.",0,0,info);
		globals.online = true;
	}
	
	// clean globals.odb from incorrect records.
	for(tmp=globals.odb,empty=true;tmp->next;old=tmp,tmp=tmp->next)
	{
		if( 	( tmp->host != NULL && strlen(tmp->host) > 0 ) &&
					( tmp->file != NULL && strlen(tmp->file) > 0 ) &&
					( tmp->type > NONE && tmp->type < UNKNOWN ) )
		// if header is complete, check (names,values) tuples.
		{
			// set names and values to NULL is they are incorrect
			for(empty=i=0;i<(MAX_ODB_T);i++,empty=false)
			{
				if( tmp->names[i] == NULL && tmp->values[i] != NULL )
				{
					empty = true;
					free((void *) tmp->values[i]);
					tmp->values[i] = NULL;
				}
				else if( tmp->names[i] != NULL && tmp->values[i] == NULL )
				{
					empty = true;
					free((void *) tmp->names[i]);
					tmp->names[i] = NULL;
				}
				else if( tmp->names[i] == NULL && tmp->values[i] == NULL )
				{
					empty = true;
				}
				else if( (strlen(tmp->names[i]) == 0 ) || (strlen(tmp->values[i]) == 0) )
				{
					empty = true;
					free((void *) tmp->names[i]);
					free((void *) tmp->values[i]);
					tmp->names[i] = NULL;
					tmp->values[i] = NULL;
				}
				
				if(empty == true)
				{
					for(count=i;count<(MAX_ODB_T-1);count++)
					{
						tmp->names[count] = tmp->names[count+1];
						tmp->values[count] = tmp->values[count+1];
					}
					tmp->names[count] = NULL;
					tmp->values[count] = NULL;
				}
			}
		}
		
		// if the header is not complete and there is touples in the record, then delete them.
		if(empty == true)
		{
			for(i=0;i<MAX_ODB_T;i++)
			{
				if(tmp->names[i] != NULL)
					free((void *) tmp->names[i]);
				if(tmp->values[i] != NULL )
					free((void *) tmp->values[i]);
			}
		}
		
		// if the header or the touples aren't complete,
		// then delete the header and replace current record with the next.
		if(empty == true || tmp->names[0] == NULL || tmp-> values[0] == NULL )
		{
			if( tmp->host != NULL)
				free((void *) tmp->host);
			if( tmp->host != NULL)
				free((void *) tmp->file);
			if( tmp->type < NONE || tmp->type > UNKNOWN )
				free((void *) tmp->type);	
			if( tmp->patrn != NULL)
				free((void *) tmp->patrn);
			
			if(old == NULL) // if this is the first item of the list
			{
				rm_head = true;
			}
			else
			{
				old->next = tmp->next;
				free((void *) tmp);
				tmp = old;
			}
		}
	}
	// if the head is to remove
	if(rm_head == true)
	{
		tmp = globals.odb->next;
		if(tmp != NULL)
		{
			free((void *)globals.odb);
			globals.odb = tmp;
		}
		else
		{
			if ( globals.online == true )
				report_error("switching off online features.",0,0,info);
			globals.online = false;
			free((void *) globals.odb);
			globals.odb = NULL;
		}
	}
	return;
}

void parser_defaults()
{
	char buff[MAX_BUFF];
	
	
	if(globals.dict == true && globals.wordlist == NULL )
	{
		snprintf(buff,MAX_BUFF,"%s/%s",CONFDIR,DEF_WRDLST);
		P_wordlist(buff);
	}
	
	if(globals.rain == true && globals.rt_root == NULL )
	{
		snprintf(buff,MAX_BUFF,"%s/%s",CONFDIR,DEF_RT_ROOT);
		P_rt_root(buff);
	}
	
	if(globals.online == true && globals.odb == NULL )
	{
		snprintf(buff,MAX_BUFF,"%s/%s",CONFDIR,DEF_ODB);
		P_odb(buff);
	}
	
	return;
}

